"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Translator = exports.Glossaries = exports.Documents = exports.Memories = void 0;
const errors_1 = require("../errors");
const net_1 = __importDefault(require("../net"));
const s3_1 = __importDefault(require("../net/s3"));
const models_1 = require("./models");
const toSnakeCase_1 = __importDefault(require("../utils/toSnakeCase"));
class Memories {
    constructor(client) {
        this.client = client;
        this.pollingInterval = 2000;
    }
    async list() {
        return await this.client.get("/memories");
    }
    async create(name, externalId) {
        return await this.client.post("/memories", {
            name,
            external_id: externalId
        });
    }
    async get(id) {
        try {
            return await this.client.get(`/memories/${id}`);
        }
        catch (e) {
            if (e instanceof errors_1.LaraApiError && e.statusCode === 404) {
                return null;
            }
            throw e;
        }
    }
    async delete(id) {
        return await this.client.delete(`/memories/${id}`);
    }
    async update(id, name) {
        return await this.client.put(`/memories/${id}`, { name });
    }
    async connect(ids) {
        const memories = await this.client.post("/memories/connect", {
            ids: Array.isArray(ids) ? ids : [ids]
        });
        return (Array.isArray(ids) ? memories : memories[0]);
    }
    async importTmx(id, tmx, gzip = false) {
        return await this.client.post(`/memories/${id}/import`, {
            compression: gzip ? "gzip" : undefined
        }, {
            tmx
        });
    }
    async addTranslation(id, source, target, sentence, translation, tuid, sentenceBefore, sentenceAfter, headers) {
        const body = {
            source,
            target,
            sentence,
            translation,
            tuid,
            sentence_before: sentenceBefore,
            sentence_after: sentenceAfter
        };
        if (Array.isArray(id)) {
            body.ids = id;
            return await this.client.put("/memories/content", body, undefined, headers);
        }
        else {
            return await this.client.put(`/memories/${id}/content`, body, undefined, headers);
        }
    }
    async deleteTranslation(id, source, target, sentence, translation, tuid, sentenceBefore, sentenceAfter) {
        const body = {
            source,
            target,
            sentence,
            translation,
            tuid,
            sentence_before: sentenceBefore,
            sentence_after: sentenceAfter
        };
        if (Array.isArray(id)) {
            body.ids = id;
            return await this.client.delete("/memories/content", body);
        }
        else {
            return await this.client.delete(`/memories/${id}/content`, body);
        }
    }
    async getImportStatus(id) {
        return await this.client.get(`/memories/imports/${id}`);
    }
    async waitForImport(mImport, updateCallback, maxWaitTime) {
        const start = Date.now();
        while (mImport.progress < 1.0) {
            if (maxWaitTime && Date.now() - start > maxWaitTime)
                throw new errors_1.TimeoutError();
            await new Promise((resolve) => setTimeout(resolve, this.pollingInterval));
            mImport = await this.getImportStatus(mImport.id);
            if (updateCallback)
                updateCallback(mImport);
        }
        return mImport;
    }
}
exports.Memories = Memories;
class Documents {
    constructor(client) {
        this.client = client;
        this.s3Client = (0, s3_1.default)();
    }
    async upload(file, filename, source, target, options) {
        const { url, fields } = await this.client.get(`/documents/upload-url`, { filename });
        await this.s3Client.upload(url, fields, file);
        const headers = (options === null || options === void 0 ? void 0 : options.noTrace) ? { "X-No-Trace": "true" } : {};
        return this.client.post("/documents", {
            source,
            target,
            s3key: fields.key,
            adapt_to: options === null || options === void 0 ? void 0 : options.adaptTo,
            glossaries: options === null || options === void 0 ? void 0 : options.glossaries,
            style: options === null || options === void 0 ? void 0 : options.style,
            password: options === null || options === void 0 ? void 0 : options.password,
            extraction_params: (options === null || options === void 0 ? void 0 : options.extractionParams) ? (0, toSnakeCase_1.default)(options.extractionParams) : undefined
        }, undefined, headers);
    }
    async status(id) {
        return await this.client.get(`/documents/${id}`);
    }
    async download(id, options) {
        const { url } = await this.client.get(`/documents/${id}/download-url`, {
            output_format: options === null || options === void 0 ? void 0 : options.outputFormat
        });
        return await this.s3Client.download(url);
    }
    async translate(file, filename, source, target, options) {
        const uploadOptions = {
            adaptTo: options === null || options === void 0 ? void 0 : options.adaptTo,
            glossaries: options === null || options === void 0 ? void 0 : options.glossaries,
            noTrace: options === null || options === void 0 ? void 0 : options.noTrace,
            style: options === null || options === void 0 ? void 0 : options.style,
            password: options === null || options === void 0 ? void 0 : options.password,
            extractionParams: options === null || options === void 0 ? void 0 : options.extractionParams
        };
        const { id } = await this.upload(file, filename, source, target, uploadOptions);
        const downloadOptions = (options === null || options === void 0 ? void 0 : options.outputFormat) ? { outputFormat: options.outputFormat } : undefined;
        const pollingInterval = 2000;
        const maxWaitTime = 1000 * 60 * 15; // 15 minutes
        const start = Date.now();
        while (Date.now() - start < maxWaitTime) {
            await new Promise((resolve) => setTimeout(resolve, pollingInterval));
            const { status, errorReason } = await this.status(id);
            if (status === models_1.DocumentStatus.TRANSLATED)
                return await this.download(id, downloadOptions);
            if (status === models_1.DocumentStatus.ERROR) {
                throw new errors_1.LaraApiError(500, "DocumentError", errorReason);
            }
        }
        throw new errors_1.TimeoutError();
    }
}
exports.Documents = Documents;
class Glossaries {
    constructor(client) {
        this.client = client;
        this.pollingInterval = 2000;
    }
    async list() {
        return await this.client.get("/glossaries");
    }
    async create(name) {
        return await this.client.post("/glossaries", { name });
    }
    async get(id) {
        try {
            return await this.client.get(`/glossaries/${id}`);
        }
        catch (e) {
            if (e instanceof errors_1.LaraApiError && e.statusCode === 404) {
                return null;
            }
            throw e;
        }
    }
    async delete(id) {
        return await this.client.delete(`/glossaries/${id}`);
    }
    async update(id, name) {
        return await this.client.put(`/glossaries/${id}`, { name });
    }
    async importCsv(id, csv, gzip = false) {
        return await this.client.post(`/glossaries/${id}/import`, {
            compression: gzip ? "gzip" : undefined
        }, {
            csv
        });
    }
    async getImportStatus(id) {
        return await this.client.get(`/glossaries/imports/${id}`);
    }
    async waitForImport(gImport, updateCallback, maxWaitTime) {
        const start = Date.now();
        while (gImport.progress < 1.0) {
            if (maxWaitTime && Date.now() - start > maxWaitTime)
                throw new errors_1.TimeoutError();
            await new Promise((resolve) => setTimeout(resolve, this.pollingInterval));
            gImport = await this.getImportStatus(gImport.id);
            if (updateCallback)
                updateCallback(gImport);
        }
        return gImport;
    }
    async counts(id) {
        return await this.client.get(`/glossaries/${id}/counts`);
    }
    async export(id, contentType, source) {
        return await this.client.get(`/glossaries/${id}/export`, {
            content_type: contentType,
            source
        });
    }
}
exports.Glossaries = Glossaries;
class Translator {
    constructor(credentials, options) {
        this.client = (0, net_1.default)(credentials.accessKeyId, credentials.accessKeySecret, options === null || options === void 0 ? void 0 : options.serverUrl);
        this.memories = new Memories(this.client);
        this.documents = new Documents(this.client);
        this.glossaries = new Glossaries(this.client);
    }
    async getLanguages() {
        return await this.client.get("/languages");
    }
    async translate(text, source, target, options) {
        const headers = {};
        if (options === null || options === void 0 ? void 0 : options.headers) {
            for (const [name, value] of Object.entries(options.headers)) {
                headers[name] = value;
            }
        }
        if (options === null || options === void 0 ? void 0 : options.noTrace) {
            headers["X-No-Trace"] = "true";
        }
        return await this.client.post("/translate", {
            q: text,
            source,
            target,
            source_hint: options === null || options === void 0 ? void 0 : options.sourceHint,
            content_type: options === null || options === void 0 ? void 0 : options.contentType,
            multiline: (options === null || options === void 0 ? void 0 : options.multiline) !== false,
            adapt_to: options === null || options === void 0 ? void 0 : options.adaptTo,
            glossaries: options === null || options === void 0 ? void 0 : options.glossaries,
            instructions: options === null || options === void 0 ? void 0 : options.instructions,
            timeout: options === null || options === void 0 ? void 0 : options.timeoutInMillis,
            priority: options === null || options === void 0 ? void 0 : options.priority,
            use_cache: options === null || options === void 0 ? void 0 : options.useCache,
            cache_ttl: options === null || options === void 0 ? void 0 : options.cacheTTLSeconds,
            verbose: options === null || options === void 0 ? void 0 : options.verbose,
            style: options === null || options === void 0 ? void 0 : options.style
        }, undefined, headers);
    }
}
exports.Translator = Translator;
