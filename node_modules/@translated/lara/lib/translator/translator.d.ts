import type { Credentials } from "../credentials";
import { type LaraClient } from "../net";
import type { MultiPartFile } from "../net/client";
import { type Document, type DocumentDownloadOptions, type DocumentUploadOptions, type Glossary, type GlossaryCounts, type GlossaryImport, type Memory, type MemoryImport, type TextBlock, type TextResult, type TranslationStyle } from "./models";
export type TranslatorOptions = {
    serverUrl?: string;
};
export type MemoryImportCallback = (memoryImport: MemoryImport) => void;
export declare class Memories {
    private readonly client;
    private readonly pollingInterval;
    constructor(client: LaraClient);
    list(): Promise<Memory[]>;
    create(name: string, externalId?: string): Promise<Memory>;
    get(id: string): Promise<Memory | null>;
    delete(id: string): Promise<Memory>;
    update(id: string, name: string): Promise<Memory>;
    connect<T extends string | string[]>(ids: T): Promise<T extends string ? Memory : Memory[]>;
    importTmx(id: string, tmx: MultiPartFile, gzip?: boolean): Promise<MemoryImport>;
    addTranslation(id: string | string[], source: string, target: string, sentence: string, translation: string, tuid?: string, sentenceBefore?: string, sentenceAfter?: string, headers?: Record<string, string>): Promise<MemoryImport>;
    deleteTranslation(id: string | string[], source: string, target: string, sentence?: string, translation?: string, tuid?: string, sentenceBefore?: string, sentenceAfter?: string): Promise<MemoryImport>;
    getImportStatus(id: string): Promise<MemoryImport>;
    waitForImport(mImport: MemoryImport, updateCallback?: MemoryImportCallback, maxWaitTime?: number): Promise<MemoryImport>;
}
export type TranslateOptions = {
    sourceHint?: string;
    adaptTo?: string[];
    instructions?: string[];
    glossaries?: string[];
    contentType?: string;
    multiline?: boolean;
    timeoutInMillis?: number;
    priority?: "normal" | "background";
    useCache?: boolean | "overwrite";
    cacheTTLSeconds?: number;
    noTrace?: boolean;
    verbose?: boolean;
    headers?: Record<string, string>;
    style?: TranslationStyle;
};
export type DocumentTranslateOptions = DocumentUploadOptions & DocumentDownloadOptions;
export type S3UploadFields = {
    acl: string;
    bucket: string;
    key: string;
};
export declare class Documents {
    private readonly client;
    private readonly s3Client;
    constructor(client: LaraClient);
    upload(file: MultiPartFile, filename: string, source: string | null, target: string, options?: DocumentUploadOptions): Promise<Document>;
    status(id: string): Promise<Document>;
    download(id: string, options?: DocumentDownloadOptions): Promise<Blob | Buffer>;
    translate(file: MultiPartFile, filename: string, source: string | null, target: string, options?: DocumentTranslateOptions): Promise<Blob | Buffer>;
}
export type GlossaryImportCallback = (glossaryImport: GlossaryImport) => void;
export declare class Glossaries {
    private readonly client;
    private readonly pollingInterval;
    constructor(client: LaraClient);
    list(): Promise<Glossary[]>;
    create(name: string): Promise<Glossary>;
    get(id: string): Promise<Glossary | null>;
    delete(id: string): Promise<Glossary>;
    update(id: string, name: string): Promise<Glossary>;
    importCsv(id: string, csv: MultiPartFile, gzip?: boolean): Promise<GlossaryImport>;
    getImportStatus(id: string): Promise<GlossaryImport>;
    waitForImport(gImport: GlossaryImport, updateCallback?: GlossaryImportCallback, maxWaitTime?: number): Promise<GlossaryImport>;
    counts(id: string): Promise<GlossaryCounts>;
    export(id: string, contentType: "csv/table-uni", source?: string): Promise<string>;
}
export declare class Translator {
    protected readonly client: LaraClient;
    readonly memories: Memories;
    readonly documents: Documents;
    readonly glossaries: Glossaries;
    constructor(credentials: Credentials, options?: TranslatorOptions);
    getLanguages(): Promise<string[]>;
    translate<T extends string | string[] | TextBlock[]>(text: T, source: string | null, target: string, options?: TranslateOptions): Promise<TextResult<T>>;
}
